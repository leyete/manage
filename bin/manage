#!/usr/bin/env bash
#
# Script to manage and rice my Linux systems
# https://github.com/mattrbeam/manage

set -eu -o pipefail

MANAGE_ROOT="$(dirname "${BASH_SOURCE[0]}")/.."

# ------------------------------------------------------------------------------
#   LOG FUNCTIONS
# ------------------------------------------------------------------------------

manage_log() {
    local COLOR

    COLOR="$1";shift
    printf "${COLOR}MANAGE | $ENVIRONMENT |$(tput sgr0 2>/dev/null) $*"
}

log_info() {
    manage_log "$(tput setaf 4 2>/dev/null)" "$@" "\n"
}

log_warn() {
    manage_log "$(tput setaf 3 2>/dev/null)" "$@" "\n"
}

log_error() {
    manage_log "$(tput setaf 1 2>/dev/null)" "$@" "\n" >&2
}

log_fatal() {
    log_error "$@"
    exit 1
}

# ------------------------------------------------------------------------------
#   MISC FUNCTIONS
# ------------------------------------------------------------------------------

detect_distribution() {
    [[ ! -f /etc/os-release ]] && \
        log_fatal "cannot read /etc/os-release. set up distro with DISTRI" \
            "environment variable."

    os_release_id="$(cat /etc/os-release | grep -oE '^ID=([A-Za-z]+)$' | cut -d'=' -f2)"
    case "$os_release_id" in
        *arch*)
            echo "arch"
            ;;
        *debian*)
            echo "debian"
            ;;
        *ubuntu*)
            echo "ubuntu"
            ;;
        *)
            log_fatal "unknown distro, set it up manually with DISTRI" \
                "environment variable"
    esac
}

is_env_installed() {
    git status --ignored "$1" | egrep -q 'Untracked|Ignored'
}

verify_env() {
    if [[ -z "$ENVIRONMENT" ]]; then
        ENVIRONMENT="$COMMAND" log_error "must provide, at least, one environment to $COMMAND"
        return 1
    fi

    if [[ ! -d "$MANAGE_ROOT/$ENVIRONMENT" ]]; then
        ENVIRONMENT="$COMMAND" log_error "invalid environment $ENVIRONMENT"
        return 1
    fi
}

clean_this() {
    git clean -dffx . >/dev/null
}

link_file() {
    declare file="$1" dest="$2"

    if [[ -f "$dest" || -d "$dest" || -L "$dest" ]]; then
        # destination file exists, check if it's a link to $file
        [[ "$(readlink $dest)" == "$file" ]] && return
        
        # if the destination file exists but it isn't a link to $file, back it
        # up before linking
        [[ ${USE_SUDO:-0} -eq 1 ]] && sudo mv "$dest" "${dest}.old" || mv "$dest" "${dest}.old"
        log_warn "$dest file already exists, moved to ${dest}.old"
    fi
    
    # link the file to the destination
    [[ ${USE_SUDO:-0} -eq 1 ]] && sudo ln -sf "$file" "$dest" || ln -sf "$file" "$dest"
}

run_root_script()
{
    declare script_type="$1" log_file="$2"
    local root_script script_failed

    if [[ $(find . -name "$script_type-root*" | wc -l) -ge 1 ]]; then
        root_script="./${script_type}-root-$DISTRI"
        # use debian root script if we are on ubuntu and no specific
        # script is available
        [[ "$DISTRI" == "ubuntu" && ! -x "$root_script" && -x "./${script_type}-root-debian" ]] && \
            root_script="./${script_type}-root-debian"

        [[ ! -x "$root_script" ]] && return

        if [[ "$ALLOW_SUDO" -ne 1 ]]; then
            log_warn "sudo not allowed, you may need to run '$root_script' manually" \
                "or use the '-s' FLAG"
            return
        fi

        set +e
        if [[ "$VERBOSE_OUTPUT" -eq 1 ]]; then
            sudo env DISTRI=$DISTRI "$root_script" 2>&1 | tee -a "$log_file"
        else
            sudo env DISTRI=$DISTRI "$root_script" >> "$log_file" 2>&1
        fi
        script_failed=$?
        set -e

        if [[ "$script_failed" -eq 0 ]]; then
            log_info "root $script_type script completed with success"
        else
            log_error "root $script_type script failed"
            cat "$log_file" >&2

            # clean before exiting
            clean_this
            exit 1
        fi
    fi
}

run_script()
{
    declare script="$1" log_file="$2"
    local script_failed

    set +e
    if [[ "$VERBOSE_OUTPUT" -eq 1 ]]; then
        DISTRI=$DISTRI PATH="$MANAGE_ROOT/bin/:$PATH" nice -n$NICE_LEVEL "./$script" 2>&1 | tee -a "$log_file"
    else
        DISTRI=$DISTRI PATH="$MANAGE_ROOT/bin/:$PATH" nice -n$NICE_LEVEL "./$script" >> "$log_file" 2>&1
    fi
    script_failed=$?
    set -e

    if [[ "$script_failed" -eq 0 ]]; then
        log_info "$script script finished"
    else
        log_error "$script script failed"
        cat "$log_file" >&2

        # clean before exiting
        clean_this
        exit 1
    fi
}

# ------------------------------------------------------------------------------
#   INSTALL COMMAND
# ------------------------------------------------------------------------------

cmd_install_usage() {
    cat <<EOF
usage: $(basename $0) [FLAGS] install [OPTIONS] [ENV ...]

Install/reinstall the supplied environments. This script links the binaries and,
optionally, the dotfiles as specified in the 'links' file.

OPTIONS:
    -a      Install all uninstalled environments (only applied if no environment
            is supplied).
    -r      If the environment is already installed, reinstall it. This option
            cleans out the environment directory before reinstalling.
    -d      Link appropriate dotfiles (according to the 'links' file)

Execute $(basename $0) with no arguments to see available flags.

EOF
}

cmd_install() {
    local OPTIND op link_dotfiles reinstall install_all

    while getopts ":dra" op; do
        case "$op" in
            a)
                install_all=1
                ;;
            d)
                link_doftiles=1
                ;;
            r)
                reinstall=1
                ;;
            *)
                ENVIRONMENT="install" log_error "invalid option ($op)"
                cmd_install_usage
                exit 1
        esac
    done
    shift $((OPTIND-1))

    environment_list="$@"
    if [[ -z "$environment_list" ]]; then
        [[ "$install_all" -eq 1 ]] && environment_list="$($0 list -u)" || \
            ENVIRONMENT="install" log_fatal "an environment is required"
    fi 

    for ENVIRONMENT in $environment_list; do
        verify_env || continue

        if [[ "${reinstall:-0}" -eq 0 ]] && is_env_installed "$PWD/$ENVIRONMENT"; then
            log_info "environment already installed, use -r to reinstall"
            continue
        fi

        cd $ENVIRONMENT
        clean_this

        # the first line in all install scripts should have the -ex flags
        if [[ $(for i in install* uninstall*; do if [[ -e "$i" ]]; then head -1 "$i"; fi; done | \
            sort | uniq | grep -v '^#!/bin/bash -ex$' | wc -l) -ne 0 ]]
        then
            log_error "not all install/uninstall scripts start with #!/bin/bash -ex"
            cd ..
            continue
        fi

        log_info "starting install, logging to $PWD/install.log"

        # run root install script
        run_root_script "install" "install.log"

        # run install script
        run_script "install" "install.log"

        cd ..
        LINK_DOTFILES=${link_dotfiles:-0} cmd_link -b $ENVIRONMENT
    done
}

# ------------------------------------------------------------------------------
#   LINK COMMAND
# ------------------------------------------------------------------------------

cmd_link_usage() {
    cat <<EOF
usage: $(basename $0) [FLAGS] link [OPTIONS] [ENV ...]

Link binaries and dotfiles for the supplied environments.

OPTIONS:
    -i      Apply links to all installed environments (only applied if no
            environment is supplied). Unsets -a.
    -a      Apply links to all environments (only applied if no environment is
            supplied). Unsets -i.
    -b      Link binaries (from 'bin' subdirectory)
    -d      Link dotfiles (according to 'links' file)

Execute $(basename $0) with no arguments to see available flags.

EOF
}

cmd_link() {
    local OPTIND op environment_list link_all link_installed

    while getopts ":dbia" op; do
        case "$op" in
            i)
                link_installed=1
                link_all=0
                ;;
            a)
                link_all=1
                link_installed=0
                ;;
            d)
                LINK_DOTFILES=1
                ;;
            b)
                LINK_BINARIES=1
                ;;
            *)
                ENVIRONMENT="link" log_error "invalid option ($op)"
                cmd_link_usage
                exit 1
                ;;
        esac
    done
    shift $((OPTIND-1))

    LINK_DOTFILES=${LINK_DOTFILES:-0}
    LINK_BINARIES=${LINK_BINARIES:-0}
    link_all=${link_all:-0}
    link_installed=${link_installed:-0}

    # if there is nothing to link, do nothing
    if [[ "$LINK_BINARIES" -eq 0 && "$LINK_DOTFILES" -eq 0 ]]; then
        ENVIRONMENT="link" log_warn "nothing to link. specify, at least, one of these options: '-b' or '-d'"
        cmd_link_usage
        exit
    fi

    environment_list="$@"
    if [[ -z "$environment_list" ]]; then
        [[ "$link_installed" -eq 1 ]] && environment_list="$($0 list -i)"
        [[ "$link_all" -eq 1 ]] && environment_list="$($0 list -iu)"
        
        [[ -z "$environment_list" ]] && ENVIRONMENT="link" log_fatal "no environments to link"
    fi

    for ENVIRONMENT in $environment_list; do
        verify_env || continue
        cd $ENVIRONMENT

        # link binaries
        if [[ "$LINK_BINARIES" -eq 1 && -d "./bin" ]]; then
            for f in $PWD/bin/*; do
                link_file "$f" "$OLDPWD/bin/$(basename $f)"
            done
            log_info "bin symlinks updated"
        fi

        # link dotfiles
        if [[ "$LINK_DOTFILES" -eq 1 && -f "./links" ]]; then
            while read -r line; do 
                dotfile="$(cut -d':' -f1 <<< $line | awk '{$1=$1};1')"
                dest="$(cut -d':' -f2 <<< $line | awk '{$1=$1};1' | envsubst)"
                
                # check if we have write permissions on the destination directory
                if [[ ! -w "$(dirname $dest)" ]]; then
                    # are we allowed to run sudo?
                    if [[ "$ALLOW_SUDO" -ne 1 ]]; then
                        log_warn "'$dotfile' is ment to be linked to '$dest', but you" \
                            "don't have write permission. consider using the '-s' FLAG" \
                            "to link it as sudo"
                        continue
                    fi

                    USE_SUDO=1 link_file "$PWD/.dotfiles/$dotfile" "$dest"
                else
                    link_file "$PWD/.dotfiles/$dotfile" "$dest"
                fi
            done <<< "$(grep -vxE '^[[:blank:]]*(#.*)?$' ./links)"
            log_info "dotfiles links updated"
        fi

        cd ..
    done
}

# ------------------------------------------------------------------------------
#   UNINSTALL COMMAND
# ------------------------------------------------------------------------------

cmd_uninstall_usage() {
    cat <<EOF
usage: $(basename $0) [FLAGS] uninstall [OPTIONS] [ENV ...]

Uninstall the supplied environments.

OPTIONS:
    -a      Uninstall all installed environments (only applied if no environment
            is supplied).

Execute $(basename $0) with no arguments to see available FLAGS.

EOF
}

cmd_uninstall() {
    local OPTIND op uninstall_all environment_list

    while getopts ":a" op; do
        case "$op" in
            a)
                uninstall_all=1
                ;;
            *)
                ENVIRONMENT="uninstall" log_error "invalid option ($op)"
                cmd_uninstall_usage
                exit 1
        esac
    done
    shift $((OPTIND-1))

    environment_list="$@"
    [[ -z "$environment_list" ]] && environment_list="$($0 list -i)"

    for ENVIRONMENT in $environment_list; do
        verify_env || continue

        if ! is_env_installed "$ENVIRONMENT"; then
            log_warn "environment not installed"
            continue
        fi

        cd $ENVIRONMENT

        log_info "starting uninstall, logging to $PWD/uninstall.log"
        
        # run root uninstall script
        run_root_script "uninstall" "uninstall.log"

        # run regular uninstall script
        run_script "uninstall" "uninstall.log"

        # clean the environment directory
        clean_this

        log_info "environment uninstalled successfully"

        cd ..
    done
}

# ------------------------------------------------------------------------------
#   LIST COMMAND
# ------------------------------------------------------------------------------

cmd_list_usage() {
    cat <<EOF
usage: $(basename $0) [FLAGS] list [COMMAND OPTIONS]

List available environments.

OPTIONS:
    -i      List installed environments
    -u      List uninstalled environments

Execute $(basename $0) with no arguments to see available flags.

EOF
}

cmd_list() {
    local OPTIND op environment_list installed uninstalled

    while getopts ":iu" op; do
        case "$op" in
            i)
                installed=1
                ;;
            u)
                uninstalled=1
                ;;
            *)
                ENVIRONMENT="list" log_error "invalid option ($op)"
                cmd_list_usage
                exit 1
        esac
    done
    shift $((OPTIND-1))

    installed=${installed:-0}
    uninstalled=${uninstalled:-0}

    for e in *; do
        [[ ! -e "$e/install" && ! -d "$e/.dotfiles" ]] && continue

        if is_env_installed "$e"; then
            [[ "$installed" -eq 1 ]] && echo "$e"
        else
            [[ "$uninstalled" -eq 1 ]] && echo "$e"
        fi
    done
}

# ------------------------------------------------------------------------------
#   MAIN ~ MANAGE SCRIPT
# ------------------------------------------------------------------------------

usage() {
    cat <<EOF
usage: $(basename $0) [FLAGS] COMMAND [COMMAND OPTIONS]

FLAGS:
    -s      Allow sudo operations (like executing root scripts)
    -v      Set verbose output
    -n      "nice" the executed script to reduce background load
    -h      Command specific help

COMMANDS:
    install     Install/reinstall the supplied environments
    link        Update bin symlinks and link dotfiles
    uninstall   Uninstall the supplied environments
    list        List available environments

EOF
}

[[ $# -eq 0 ]] && usage && exit
[[ -z ${DISTRI+x} ]] && DISTRI="$(detect_distribution)"

# parse the script flags
while getopts ":svnh" op; do
    case "$op" in
        s)
            ALLOW_SUDO=1
            ;;
        v)
            VERBOSE_OUTPUT=1
            ;;
        h)
            SHOW_HELP=1
            ;;
        n)
            NICE_LEVEL=10
            ;;
        *)
            ENVIRONMENT="ERROR" log_error "invalid flag ($op)"
            usage
            exit 1
    esac
done
shift $((OPTIND-1))

SHOW_HELP=${SHOW_HELP:-0}
ALLOW_SUDO=${ALLOW_SUDO:-0}
VERBOSE_OUTPUT=${VERBOSE_OUTPUT:-0}
NICE_LEVEL=${NICE_LEVEL:-0}

# parse the command
COMMAND="$1"; shift

if [[ -z "$COMMAND" ]]; then
    ENVIRONMENT="ERROR" log_error "missing command"
    usage
    exit 1
fi

case "$COMMAND" in
    install|link|uninstall)
        [[ "$SHOW_HELP" -eq 1 ]] && cmd_${COMMAND}_usage || cmd_${COMMAND} "$@"
        ;;
    *)
        ENVIRONMENT="$COMMAND" log_error "invalid command '$COMMAND'"
        usage
        exit 1
esac
